# AGENTS.md

**Audience:** code assistants (Aider, Cody, Copilot Chat, etc.) working on this repository.
**Mode:** read-only + patch-only. No command execution.

## Goals

* Generate **patches/PRs** for:
  * Tests and test coverage improvements.
  * Documentation updates and migrations.
  * Small, mechanical refactors (safe, localised).
* Never run the project, servers, or scripts. The user/CI handles compilation and websites (watch mode already running).
* Spot mistakes in the docs where they do not correctly reflect the code.

## Repository Overview

This is a monorepo with a large number of interdependencies. The repo is split into 4 main categories based on the root folders, each of which have a `<category>/website` project for their own website:

* `utils` - lots of helper projects that we use to build the main projects. Website: https://star.graphile.org ("star" as in "asterisk" as in "everything else")
  * `pg-sql2` - safe (and extremely fast) SQL template strings
  * `graphile-config` - standard utils around creating plugins and presets, used throughout Graphile projects.
  * `graphile-export` - can export an in-memory GraphQL schema (with resolvers/plans) as an executable JS file - particularly useful for serverless.
  * `pg-introspection` - exposes the PostgreSQL system catalog via TypeScript interfaces with documentation pulled from postgres.
* `grafast` - a new cutting-edge planning and execution engine for GraphQL. Uses GraphQL.js for schema elements (`new GraphQLObjectType`, etc) but completely replaces execution and output logic. Website: https://grafast.org
  * `grafserv` - a Grafast-optimized server
  * `@grafserv/persisted` - a plugin for Grafserv for persisted operations / trusted documents.
  * `ruru` - a Grafast-optimized GraphiQL distribution
  * `@dataplan/pg` - a collection of Grafast "step classes" for dealing with PostgreSQL databases
* `graphile-build` - the Graphile Build project produces a GraphQL schema via a set of plugins. Website: https://build.graphile.org
  * `graphile-build-pg` - teaches Graphile Build how to add schema elements from PostgreSQL resources (tables, functions)
  * `@graphile/simplify-inflection` - a highly recommended plugin that uses simpler names in GraphQL (but increases the chance of collisions, hence not included in the default experience)
  * `graphile-utils` - the "bread and butter" plugin factories that help people do common manipulations of a PostGraphile schema with minimal effort
* `postgraphile` - autogenerated and highly extensible/customiseable GraphQL API server/schema generator built using Graphile Build and executed via Grafast. Website: https://postgraphile.org
  * `pgl` - a shortcut to the `postgraphile` binary that also takes care of installing all the peerDependencies for you (for compatibility with `npx`

## Hard Guardrails (must follow)

1. **Never edit versioned docs:** Do **not** modify anything under:

   ```
   */website/versioned_docs/**
   ```

   These are snapshots taken at release time. If you need to change content that appears there, **edit the source (unversioned) doc** instead.

2. **No commands. No shell. No network.**

   * Do not ask to run `yarn`, `npm`, `pnpm`, `node`, `ts-node`, `docker`, or any shell.
   * Do not run servers, websites, or build steps. The user already runs these in watch mode.

3. **Patch-only writes.**

   * Output changes as **unified diffs** (or a clearly separated list of file edits).
   * Do not commit, tag, publish, or change CI settings.

4. **Stay inside the repo.**

   * Do not reference absolute paths or `$HOME`.
   * Do not touch dotfiles unrelated to the change (e.g. global editor config).

5. **Keep scope tight.**

   * Prefer many small PRs over one large PR.
   * Avoid cross-cutting rewrites unless explicitly requested.

## Allowed Actions

* Read files and propose edits.
* Write tests; update fixtures and test helpers.
* Update docs (e.g., guides, reference, examples).
* Add or adjust comments, JSDoc/TSDoc, README snippets.
* Suggest CI/test commands **in prose**; do not execute them.

## Preferred Patch Style

* Follow current formatting/lint rules; if unsure, **do not** add style-only churn.
* Include a concise rationale at the top of each patch explaining **why** the change is needed.
* Keep code samples runnable in principle, but **do not** add scripts to run them.

## Documentation Rules

* **Edit only the canonical (unversioned) docs**. Never touch `*/website/versioned_docs/**`.
* Avoid moving/renaming pages unless it's essential.
* Update internal links when moving content.

## Testing Rules

* Prefer **incremental** tests: cover public APIs and critical paths first.
* Use existing test utilities and patterns; mirror nearby tests.
* Keep tests deterministic; avoid timers, sleep, and real networks.
* If flakiness is suspected, mark and explain in a comment; do not introduce retries without cause.
* Many of the integration tests work by writing `*.test.graphql` files, which the system will run and capture snapshots of data, plans, errors and executed SQL. Do not generate these snapshot files, only the `.test.graphql` files are needed.
* The test suite uses a lot of different schema configurations (see the `#>` comments at the top of `*.test.graphql` files), so it may be hard to determine which fields are available. Look for a test in the `schemas` folder that has a similar configuration, its snapshot can be a guide.

## Communication & PR Hygiene

* Each PR:
  * Title: concise, imperative.
  * Description: rationale, scope, and any migration notes. Concise.
  * Checklist: docs updated? tests added/updated? user-visible changes noted? changeset added?
* Avoid changing lockfiles or versions unless the change truly requires it, and call that out explicitly.

## Things to Avoid

* Editing `versioned_docs/**` (repeating for emphasis).
* Running or adding commands, scripts, or services.
* Large refactors without an issue/plan.
* Stylistic rewrites without functional gain.
* Changing CI, release tooling, or publishing config.

## Assumptions

* The codebase is **constantly recompiled** by the user/CI; you do not need to trigger builds.
* The websites/docs dev servers are **already running in watch mode**; you do not need to start/stop anything.
* If a change would normally require running something, **state it in prose** instead of executing it.

## Ready-to-Use Prompts (for the assistant)

* “Propose a **single** diff that updates the unversioned docs to replace references to `<OLD_API>` with `<NEW_API>`. Include before/after snippets and a short migration note. **Do not edit** `versioned_docs/**`.”
* “Add unit tests for `<MODULE>` covering error paths X/Y and null handling. Follow the existing test style in `<NEARBY_TEST_FILE>`. Output one diff.”
* “Scan for doc pages that still mention `<DEPRECATED_FEATURE>`. List the file paths and propose a patch to fix them, excluding `versioned_docs/**`.”
