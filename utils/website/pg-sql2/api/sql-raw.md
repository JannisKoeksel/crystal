---
sidebar_position: 8
title: "sql.raw()"
---

# `sql.raw(text)`

**DO NOT USE** - This function invites SQL injection vulnerabilities.

## Syntax

```typescript
sql.raw(text: string): SQL
```

## Parameters

- `text` - Raw SQL text to embed directly

## Description

**⚠️ EXTREME DANGER: YOU ARE INVITING SQL INJECTION**

This function embeds raw SQL text directly into a query with **NO escaping, validation, or safety checks whatsoever**. By using this function, you are explicitly bypassing all of pg-sql2's SQL injection protections.

**This is an escape hatch only.** The number of valid use cases for this function are vanishingly small. In 99.9% of cases, there is a safer alternative using other pg-sql2 functions.

**DO NOT USE unless you are absolutely certain:**

- The text contains zero dynamic content
- The text is completely hard-coded
- No user input can influence the text in any way
- You have exhausted all other safer alternatives

## What NOT To Do (and what to do instead)

```js
// ❌ NEVER with user input - SQL injection vulnerability!
const userInput = req.query.sort; // Could be "; DROP TABLE users; --"
const badQuery = sql`SELECT * FROM users ${sql.raw(userInput)}`; // DANGEROUS!

// ❌ NEVER with dynamic content
const tableName = getUserSelectedTable(); // User controlled = dangerous
const badQuery2 = sql`SELECT * FROM ${sql.raw(tableName)}`; // DANGEROUS!

// ❌ NEVER for values
const username = req.body.username;
const badQuery3 = sql`SELECT * FROM users WHERE name = ${sql.raw(`'${username}'`)}`; // DANGEROUS!
```

## Safer Alternatives

Instead of `sql.raw()`, use these safer alternatives:

### For Identifiers

```js
// ❌ Dangerous
sql`SELECT * FROM ${sql.raw(tableName)}`;

// ✅ Safe
sql`SELECT * FROM ${sql.identifier(tableName)}`;
```

### For Values

```js
// ❌ Dangerous
sql`WHERE id = ${sql.raw(userId.toString())}`;

// ✅ Safe
sql`WHERE id = ${sql.value(userId)}`;
```

### For Dynamic SQL Parts

```js
// ❌ Dangerous
const sortDirection = userInput; // "ASC" or "DESC"
sql`SELECT * FROM users ORDER BY name ${sql.raw(sortDirection)}`;

// ✅ Safe with validation
const sortDirection = userInput === "DESC" ? "DESC" : "ASC";
sql`SELECT * FROM users ORDER BY name ${sql.raw(sortDirection)}`;

// ✅ Even better - use literals for known values
const isDescending = userInput === "DESC";
sql`SELECT * FROM users ORDER BY name ${sql.literal(isDescending ? "DESC" : "ASC")}`;
```

### For Complex Expressions

```js
// If you must use raw SQL, validate it extensively first
function createOrderClause(column, direction) {
  // Strict validation
  const allowedColumns = ["name", "email", "created_at", "updated_at"];
  const allowedDirections = ["ASC", "DESC"];

  if (!allowedColumns.includes(column)) {
    throw new Error(`Invalid column: ${column}`);
  }

  if (!allowedDirections.includes(direction)) {
    throw new Error(`Invalid direction: ${direction}`);
  }

  // Now safe to use raw (but identifier would be even better)
  return sql.raw(`ORDER BY ${column} ${direction}`);
}
```

## Return Value

Returns a `SQL` fragment containing the raw text that will be inserted verbatim into the compiled query.

## When You Might Need This

Very rare cases where `sql.raw()` might be necessary:

- Complex SQL expressions that pg-sql2 doesn't directly support
- Database-specific syntax that requires exact formatting
- Performance-critical queries where you need precise control
- Working with SQL that's generated by other trusted tools

## Security Checklist

Before using `sql.raw()`, verify ALL of these:

- [ ] The text is completely hard-coded (no variables)
- [ ] No user input can influence the text in any way
- [ ] The text has been reviewed by a security-aware developer
- [ ] You've considered and ruled out all safer alternatives
- [ ] The text is valid SQL that won't break the query
- [ ] You understand the SQL injection risks

## Better Patterns

Instead of reaching for `sql.raw()`, consider:

1. **Build a feature request** - If pg-sql2 doesn't support something you need
2. **Use composition** - Break complex SQL into smaller, safer fragments
3. **Validate strictly** - If you must use dynamic content, validate it extensively
4. **Use allowlists** - Only allow specific, pre-approved values

```js
// Instead of raw SQL for sorting
function buildSortClause(options) {
  const columnMap = {
    name: sql.identifier("users", "name"),
    email: sql.identifier("users", "email"),
    date: sql.identifier("users", "created_at"),
  };

  const column = columnMap[options.sortBy] || columnMap["date"];
  const direction = options.sortDesc ? sql.literal("DESC") : sql.literal("ASC");

  return sql`ORDER BY ${column} ${direction}`;
}
```

Remember: If you find yourself needing `sql.raw()` frequently, consider whether pg-sql2 is the right tool for your use case, or whether the library needs additional features to support your patterns safely.
