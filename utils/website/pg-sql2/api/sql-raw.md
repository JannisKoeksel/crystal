---
sidebar_position: 8
title: "sql.raw()"
---

# `sql.raw(text)`

**DO NOT USE** - This function invites SQL injection vulnerabilities.

## Syntax

```typescript
sql.raw(text: string): SQL
```

## Parameters

- `text` - Raw SQL text to embed directly

## Description

**⚠️ EXTREME DANGER: YOU ARE INVITING SQL INJECTION**

Embeds raw SQL with **zero safety checks**. This bypasses all SQL injection protections.

**This is an escape hatch only.** The number of valid use cases for this function are vanishingly small. In 99.9% of cases, there is a safer alternative using other pg-sql2 functions.

## Safer Alternatives

```js
// ❌ sql.raw(userInput) -> SQL injection!
// ✅ sql.identifier(tableName) for tables/columns
// ✅ sql.value(userInput) for values
// ✅ sql.literal("ASC") for constants
```

Use `sql.identifier()`, `sql.value()`, or `sql.literal()` instead.
throw new Error(`Invalid column: ${column}`);
}

if (!allowedDirections.includes(direction)) {
throw new Error(`Invalid direction: ${direction}`);
}

// Now safe to use raw (but identifier would be even better)
return sql.raw(`ORDER BY ${column} ${direction}`);
}

````

## Return Value

Returns a `SQL` fragment containing the raw text that will be inserted verbatim into the compiled query.

## When You Might Need This

Very rare cases where `sql.raw()` might be necessary:

- Complex SQL expressions that pg-sql2 doesn't directly support
- Database-specific syntax that requires exact formatting
- Performance-critical queries where you need precise control
- Working with SQL that's generated by other trusted tools

## Security Checklist

Before using `sql.raw()`, verify ALL of these:

- [ ] The text is completely hard-coded (no variables)
- [ ] No user input can influence the text in any way
- [ ] The text has been reviewed by a security-aware developer
- [ ] You've considered and ruled out all safer alternatives
- [ ] The text is valid SQL that won't break the query
- [ ] You understand the SQL injection risks

## Better Patterns

Instead of reaching for `sql.raw()`, consider:

1. **Build a feature request** - If pg-sql2 doesn't support something you need
2. **Use composition** - Break complex SQL into smaller, safer fragments
3. **Validate strictly** - If you must use dynamic content, validate it extensively
4. **Use allowlists** - Only allow specific, pre-approved values

```js
// Instead of raw SQL for sorting
function buildSortClause(options) {
  const columnMap = {
    name: sql.identifier("users", "name"),
    email: sql.identifier("users", "email"),
    date: sql.identifier("users", "created_at"),
  };

  const column = columnMap[options.sortBy] || columnMap["date"];
  const direction = options.sortDesc ? sql.literal("DESC") : sql.literal("ASC");

  return sql`ORDER BY ${column} ${direction}`;
}
````

Remember: If you find yourself needing `sql.raw()` frequently, consider whether pg-sql2 is the right tool for your use case, or whether the library needs additional features to support your patterns safely.
