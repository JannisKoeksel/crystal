---
sidebar_position: 5
---

import Mermaid from "@theme/Mermaid";
import init from "./mermaid-init.mermaid?raw";

# Plan resolvers

When planning a GraphQL operation, we combine the plans from every field
requested in the operation into an execution plan that we then optimize. "Field
plan resolvers" are the functions that detail the plan for each field (there
can also be plan resolvers on arguments, input fields, and even enum values;
but that's more advanced than most people need).

Plan resolvers are synchronous (they must not return promises) since they do
not deal with actual runtime data, instead detailing the steps needed to
process all possible data that will be seen at runtime.

## Field plan resolvers

At operation planning time, each time a field is referenced that field's plan
resolver will be called and the result will be combined into the operation
plan. When calling the field's resolver, <Grafast /> will pass the "parent
step" and a "field args" object. The plan resolver may create as many
intermediate steps as it likes, but it must return exactly one step that
represents the result of the field.

In the case of a field that has a polymorphic type, the step that is returned
must be a polymorphic-capable plan (see [polymorphism](./polymorphism.mdx)). In
the case of a field that has a list type, the step that is returned must
produce lists when executed.

A plan resolver can be used instead of, or in addition to, a traditional
resolver. Since plan resolvers run only when the operation is being planned, not
when it is being executed, they do not have access to any data ─ only other
steps.

Like regular resolvers, the first two arguments to a plan resolver represent the
parent data and the arguments respectively. However, since we're dealing in
potentials rather than concrete data, both of these are a little different:

### Parent step

The first argument, the "parent step," is a step that represents the data from
the parent. When the parent field has an object type, the "parent step" is
simply the step that the parent field resolved to. When the parent field has a
list or polymorphic type, the "parent step" will be the resolved step that
represents an entry from the list or the concrete object type for polymorphism.

### Field arguments

The second argument, the "field arguments" (`fieldArgs`), is an object with
access methods to read the arguments. We'll expand on that below in the
[FieldArgs](#fieldargs) section.

### Example

A plan resolver might look something like:

```ts
function plan_resolver(
  $parent: ExecutableStep,
  args: FieldArgs,
): ExecutableStep {
  const $friends = $parent.getRelation("friends");
  $friends.limit(args.get("limit"));
  return $friends;
}
```

:::note

By convention, when a variable represents a step we start the variable's name
with a `$`.

:::

Of course the actual body of the plan resolver function will vary based on your
own application's needs.

## Execution order &amp; side effects

Grafast is **declarative**: steps form a directed acyclic graph (DAG) and only dependencies determine order. There is no implicit procedural sequencing. Two rules matter:

1. Dependencies before dependents.
2. Steps **implicitly** depend on the previous side effect step, if any.

This can be surprising during mutations: steps created before a mutation might
execute **after** the mutation unless one of the rules above says otherwise.

### Example

```ts
const $before = users.get({ id: $rowId });
const $valueBefore = $before.get("value1");

const $after = updateUser($rowId);
const $valueAfter = $after.get("value1");

const $log = sideEffect(
  [$valueBefore, $valueAfter],
  ([before, after]) => void console.log({ before, after }),
);
```

**Default graph (no extra side effects):**

<Mermaid
  chart={`
${init}
  $log:::plan
  $before:::plan --> $valueBefore:::plan --> $log
  $after:::plan --> $valueAfter:::plan --> $log
  class $log,$after sideeffectplan
  class $before,$valueBefore,$after,$valueAfter,$log bucket0
`}
/>

The engine may execute `$after` (mutation) before `$valueBefore`, because
nothing forbids it according to the two rules above.

**Force “read-before-write” by marking `$valueBefore` as a side effect:**

```diff
 const $before = users.get({ id: $rowId });
 const $valueBefore = $before.get("value1");
+$valueBefore.hasSideEffect = true;

 const $after = updateUser($rowId);
 const $valueAfter = $after.get("value1");

 const $log = sideEffect(
   [$valueBefore, $valueAfter],
   ([before, after]) => void console.log({ before, after })
 );
```

This adds an _implicit_ edge from `$valueBefore` to later steps (including `$after`):

<Mermaid
  chart={`
${init}
  $log:::plan
  $before:::plan --> $valueBefore:::plan --> $log
  $after:::plan --> $valueAfter:::plan --> $log
  $valueBefore -.-o $after
  class $log,$after,$valueBefore sideeffectplan
  class $before,$valueBefore,$after,$valueAfter,$log bucket0
`}
/>

Now `$valueBefore` must run before `$after`, so your log shows the true “before” and “after”.

### When to use which

- Prefer **explicit data deps** when possible (e.g. make the read feed the write).
- Use `hasSideEffect = true` when you need **ordering without data flow** (logging, metrics, authorization gates, idempotency checks).
- Don’t sprinkle `hasSideEffect` on hot paths unnecessarily; it reduces reordering freedom.

## Specifying a field plan resolver

When building a GraphQL schema programatically, plan resolvers are stored into
`extensions.grafast.plan` of the field; for example:

```ts {9-15}
import { GraphQLSchema, GraphQLObjectType, GraphQLInt } from "graphql";
import { constant } from "grafast";

const Query = new GraphQLObjectType({
  name: "Query",
  fields: {
    meaningOfLife: {
      type: GraphQLInt,
      extensions: {
        grafast: {
          plan() {
            return constant(42);
          },
        },
      },
    },
  },
});

export const schema = new GraphQLSchema({
  query: Query,
});
```

If you are using `makeGrafastSchema` then the field plan resolver for the field
`fieldName` on the object type `typeName` would be indicated via the
`objects[typeName].plans[fieldName]` property:

```ts {12-14}
import { makeGrafastSchema, constant } from "grafast";

export const schema = makeGrafastSchema({
  typeDefs: /* GraphQL */ `
    type Query {
      meaningOfLife: Int
    }
  `,
  objects: {
    Query: {
      plans: {
        meaningOfLife() {
          return constant(42);
        },
      },
    },
  },
});
```

### Asserting an object type's step

Object types in Gra*fast* can indicate that they must be represented by a
particular step or set of steps to guarantee that the methods on those steps
are available to the field plan resolvers; this can help to catch bugs early.

This indication takes one of two forms, either it's explicitly the step class
itself, or it's an assertion function that checks that the incoming step is of
an appropriate type and throws an error otherwise.

When defining a schema programatically, `assertStep` is defined via
`objectTypeConfig.extensions.grafast.assertStep`, for example:

```ts {8-14}
import { GraphQLObjectType } from "graphql";
import { ObjectStep } from "grafast";

const MyObject = new GraphQLObjectType({
  name: "MyObject",
  extensions: {
    grafast: {
      assertStep: ObjectStep,
      /* Or:
        assertStep($step) {
          if ($step instanceof ObjectStep) return;
          throw new Error(`Type 'MyObject' expects a step of type ObjectStep; instead received a step of type '${$step.constructor.name}'`);
        }
       */
    },
  },
  fields: {
    a: {
      extensions: {
        grafast: {
          plan($obj: ObjectStep) {
            return $obj.get("a");
          },
        },
      },
    },
  },
});
```

When defined via `makeGrafastSchema` we cannot call the property `assertStep`
directly as it might conflict with a field name, so instead we use
`assertStep`, knowing that GraphQL forbids fields to start with `__` (two
underscores) since those names are reserved for introspection:

```ts {11-17}
import { makeGrafastSchema, ObjectStep } from "grafast";

const schema = makeGrafastSchema({
  typeDefs: /* GraphQL */ `
    type MyObject {
      a: Int
    }
  `,
  objects: {
    MyObject: {
      assertStep: ObjectStep,
      /* Or:
        assertStep($step) {
          if ($step instanceof ObjectStep) return;
          throw new Error(`Type 'MyObject' expects a step of type ObjectStep; instead received a step of type '${$step.constructor.name}'`);
        }
       */
      plans: {
        a($obj: ObjectStep) {
          return $obj.get("a");
        },
      },
    },
  },
});
```

:::tip

Generally adding a step assertion is optional; however when there's a union or
interface type all types within it must agree whether a step is expected or
not. If you want to require steps everywhere but you don't care for a particular
type what the step actually is, you can use `assertStep: ExecutableStep` or
`assertStep: () => true`.

:::

## FieldArgs

The `FieldArgs` object gives ways of interacting with the values passed as
arguments to a field.

### Accessing argument values

You can retrieve a step representing a field argument's value either via the
matching `$`-prefixed property of the `fieldArgs` object, or via the `.getRaw()`
method.

Consider this schema:

```graphql
input BookFilter {
  author: String
  publishedAfter: Int
}

type Query {
  bookCount(search: String, filter: BookFilter): Int!
}
```

You can access using the `$`-prefixed properties:

```ts
function bookCount($parent, fieldArgs) {
  const { $search, $filter } = fieldArgs;
  const { $author, $publishedAfter } = $filter;
}
```

Or, equivalently, via `.getRaw()`:

```ts
function bookCount($parent, fieldArgs) {
  const $search = fieldArgs.getRaw("search");
  const $filter = fieldArgs.getRaw("filter");
  const $author = fieldArgs.getRaw(["filter", "author"]);
  const $publishedAfter = fieldArgs.getRaw(["filter", "publishedAfter"]);
}
```

### Argument plans

:::info[Advanced]

You wouldn't typically use this if you're writing your schema by hand, but it
can be helpful if you're using automatic schema generation as it allows
arguments to handle their own logic.

:::

Sometimes rather than fetching and using the raw argument value directly, you
want to apply the argument to your field plan. This allows you to keep your
argument logic separate from your field plan logic. For this, your argument
would have an `applyPlan` method defined on it:

```ts
const schema = makeGrafastSchema({
  typeDefs: /* GraphQL */ `
    type Query {
      users(first: Int, offset: Int): [User!]!
    }
  `,
  objects: {
    Query: {
      plans: {
        users: {
          // The (simple) plan for the field
          plan($query, fieldArgs) {
            const $allUsers = users.find();
            return $allUsers;
          },
          // These become `applyPlan` methods on the arguments:
          args: {
            // $target will be the return result of the field plan, i.e.
            // `$allUsers` above
            first($query, $target, val) {
              const $first = val.getRaw();
              $target.setFirst($first);
            },
            offset($query, $target, val) {
              const $offset = val.getRaw();
              $target.setOffset($offset);
            },
          },
        },
      },
    },
  },
});
```

Grafast will automatically call each of the arguments' plans once the field plan
resolver has returned, passing the step yielded from the field plan as the
`$target` for the arguments.

:::info[Optimization: may be skipped in some circumstances]

If Grafast can determine statically that your argument will not be passed at
runtime (i.e. will be `undefined`) then it may choose to skip calling the
`applyPlan()` method for that argument.

:::

#### Triggering auto-application early

**ADVANCED**

If you want to wrap a plan resolver with a higher order function, you might want
all of the arguments to have already been applied before your wrapper plan's
logic continues. You can trigger the auto-application early with the
`fieldArgs.autoApply($target)` method:

```ts
const oldPlan = usersField.extensions.grafast.plan;
usersField.extensions.grafast.plan = function (...params) {
  // Call the old plan method
  const $target = oldPlan.apply(this, params);

  // Perform the auto-application of arguments early:
  const [_, fieldArgs] = params;
  fieldArgs.autoApply($target);

  // Now do whatever logic we need to do:
  if (!$target.getFirst()) {
    $target.setFirst(constant(10));
  }

  return $target;
};
```

#### Applying deeper inputs

**INCREDIBLY ADVANCED**

Sometimes complex inputs make more sense as "commands" than "data" - take for
example a complex `filter` argument to a field that pulls from an SQL database.
Here you want to manipulate the query that would be sent to the DB, rather than
just passing the data into the DB; and the changes to the query will be dynamic
based on the user input.

For this, we have the [applyInput()][./standard-steps/applyInput.md] step, but
calling it can be a little verbose, so we give you a shortcut:

```ts
fieldArgs.apply($target, path, callback)
```

- `$target`: the "applyable" step (has a `.apply()` method) to target
- `path`: the position in the input tree to start applying, e.g. `["condition"]`
- `callback(target, inputValue)`: called at runtime with the target and the
input value, either applies the inputValue to the target, or returns a new
target for child fields to be applied to

:::note[Reach out!]

We recognize this is under-documented; if you actually need it for something
then reach out via [the Discord](https://discord.gg/graphile) or file an issue
and we can look at expanding it.

:::

<!-- TODO: document `typeAt` too. -->
